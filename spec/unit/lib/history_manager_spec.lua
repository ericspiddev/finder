local history = require("nvim-scout.lib.history_manager")

describe('history', function ()
    it('knows when the list is empty or not', function ()
        local hm = history:new(10)
        assert(hm:is_empty())
        hm.entries[1] = "test"
        assert.equals(hm:is_empty(), false)
        hm.entries = {}
        assert(hm:is_empty())
    end
    )

    it('is able to add entries to the table', function ()
        local hm = history:new(10)
        hm:add_entry("First search")
        assert.equals(hm.entries[1], "First search")
        hm:add_entry("Second")
        assert.equals(hm.entries[2], "Second")
        hm:add_entry("Third")
        assert.equals(hm.entries[3], "Third")
        hm:add_entry("Fourth")
        assert.equals(hm.entries[4], "Fourth")
    end)

    it('only adds string to the history table', function ()
        local hm = history:new(10)
        hm:add_entry(1)
        assert(hm:is_empty())
        hm:add_entry(1.21)
        assert(hm:is_empty())
        hm:add_entry(function () print("don't add me to the list") end)
        assert(hm:is_empty())
        hm:add_entry({test = 1.0,
            {nested = true}
        })
        assert(hm:is_empty())
        hm:add_entry({1, 2, 3})
        assert(hm:is_empty())
    end)

    it('increments the history index when adding entries and wraps around', function ()
        local hm = history:new(3)
        assert.equals(hm.history_index, 1)
        hm:add_entry("where")
        assert.equals(hm.entries[1], "where")
        assert.equals(hm.history_index, 2)
        hm:add_entry("is")
        assert.equals(hm.entries[2], "is")
        assert.equals(hm.history_index, 3)
        hm:add_entry("it")
        assert.equals(hm.history_index, 1)
        assert.equals(hm.entries[3], "it")

        hm:add_entry("here it is")
        assert.equals(hm.entries[1], "here it is")
        assert.equals(hm.history_index, 2)
    end)

    it('returns the previous and next entries', function ()
        local hm = history:new(10)
        hm:add_entry("eric")
        hm:add_entry("spidle")
        hm:add_entry("is")
        hm:add_entry("so")
        hm:add_entry("cool")
        assert.equals(hm.viewing_index, 0) -- 0 to start so our first increment goes to first entry
        assert.equals(hm:get_next_entry(), "eric")
        assert.equals(hm.viewing_index, 1)
        assert.equals(hm:get_next_entry(), "spidle")
        assert.equals(hm.viewing_index, 2)
        assert.equals(hm:get_next_entry(), "is")
        assert.equals(hm.viewing_index, 3)
        assert.equals(hm:get_next_entry(), "so")
        assert.equals(hm.viewing_index, 4)
        assert.equals(hm:get_next_entry(), "cool")
        assert.equals(hm.viewing_index, 5)
        assert.equals(hm:get_next_entry(), "eric")
        assert.equals(hm.viewing_index, 1)

        hm = history:new(10)
        hm:add_entry("eric")
        hm:add_entry("spidle")
        hm:add_entry("is")
        hm:add_entry("so")
        hm:add_entry("cool")
        assert.equals(hm:get_previous_entry(), "cool")
        assert.equals(hm:get_previous_entry(), "so")
        assert.equals(hm:get_previous_entry(), "is")
        assert.equals(hm:get_previous_entry(), "spidle")
        assert.equals(hm:get_previous_entry(), "eric")
    end)


    it('wraps between the min and max entries', function ()
        local hm = history:new(5)
        assert.equals(hm.viewing_index, 0) -- 0 to start so our first increment goes to first entry
        hm:add_entry("eric")
        hm:add_entry("spidle")
        hm:add_entry("is")
        hm:add_entry("so")
        hm:add_entry("cool")
        assert.equals(hm:get_previous_entry(), "cool")
        assert.equals(hm:get_previous_entry(), "so")
        assert.equals(hm:get_previous_entry(), "is")
        assert.equals(hm:get_previous_entry(), "spidle")
        assert.equals(hm:get_previous_entry(), "eric")
        assert.equals(hm:get_previous_entry(), "cool")
        assert.equals(hm:get_next_entry(), "eric")
        assert.equals(hm:get_previous_entry(), "cool")
        assert.equals(hm:get_next_entry(), "eric")

        hm = history:new(5)
        assert.equals(hm.viewing_index, 0) -- 0 to start so our first increment goes to first entry
        hm:add_entry("eric")
        hm:add_entry("spidle")
        hm:add_entry("is")
        hm:add_entry("so")
        hm:add_entry("cool")

        assert.equals(hm:get_next_entry(), "eric")
        assert.equals(hm:get_next_entry(), "spidle")
        assert.equals(hm:get_next_entry(), "is")
        assert.equals(hm:get_next_entry(), "so")
        assert.equals(hm:get_next_entry(), "cool")
        assert.equals(hm:get_next_entry(), "eric")
        assert.equals(hm:get_previous_entry(), "cool")
        assert.equals(hm:get_next_entry(), "eric")
        assert.equals(hm:get_previous_entry(), "cool")
    end)

    it('ignores out of bounds indices for entries', function ()
        local hm = history:new(8)
        hm:add_entry("one")
        hm:add_entry("two")
        hm:add_entry("three")
        hm:add_entry("four")
        hm:add_entry("five")
        assert.equals(hm:get_entry(-10), nil)
        assert.equals(hm:get_entry(0), nil)
        assert.equals(hm:get_entry(6), nil)
        assert.equals(hm:get_entry(102), nil)
        assert.equals(hm:get_entry(), nil)
        assert.equals(hm:get_entry(1), "one")
        assert.equals(hm:get_entry(3), "three")
        assert.equals(hm:get_entry(5), "five")
    end)

    it('does not double add a history entry twice in a row', function ()
        local hm = history:new(8)
        hm:add_entry("one")
        hm:add_entry("one")
        assert.equals(1,#hm.entries)
        hm:add_entry("two")
        hm:add_entry("two")
        hm:add_entry("two")
        hm:add_entry("two")
        hm:add_entry("two")
        assert.equals(2,#hm.entries)
    end)
end)
